<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI Self-Analysis Quiz</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Use Times New Roman for better symbol rendering -->
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    
    <!-- MathJax for rendering LaTeX symbols -->
    <script>
      MathJax = {
        tex: {
          inlineMath: [['$', '$'], ['\\(', '\\)']],
          displayMath: [['$$', '$$'], ['\\[', '\\]']],
          processEscapes: true
        }
        // Removed SVG config, CHTML is now default
      };
    </script>
    <!-- UPDATED: Switched from tex-svg.js to tex-chtml.js for better PDF export -->
    <script type="text/javascript" id="MathJax-script" async
      src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js">
    </script>
    
    <!-- Lottie for Animations -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/lottie-web/5.12.2/lottie.min.js"></script>
    
    <!-- jsPDF and html2canvas for PDF Export -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>

    <!-- NEW: PDF.js for PDF processing -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
    <script>
        // Set worker path for PDF.js
        if (typeof pdfjsLib !== 'undefined') {
            pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';
        }
    </script>

    <style>
        body {
            /* Changed font to serif for better academic/symbol rendering */
            font-family: 'Inter', sans-serif;
        }
        .file-input-label {
            cursor: pointer;
            transition: all 0.3s ease;
        }
        .file-input-label:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0,0,0,0.1);
        }
        .option-btn {
            transition: all 0.2s ease-in-out;
        }
        .option-btn:hover:not(:disabled) {
            transform: scale(1.03);
            background-color: #f0f4ff;
        }
        .option-btn:disabled {
            cursor: not-allowed;
        }
        .correct {
            background-color: #d1fae5 !important;
            border-color: #10b981 !important;
            color: #065f46 !important;
        }
        .incorrect {
            background-color: #fee2e2 !important;
            border-color: #ef4444 !important;
            color: #991b1b !important;
        }
        .fade-in {
            animation: fadeIn 0.5s ease-in-out;
        }
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }
        /* Modal styles */
        .modal-backdrop {
            background-color: rgba(0, 0, 0, 0.6);
            z-index: 40;
        }
        .modal {
            z-index: 50;
        }
        /* Ensure summary in PDF is not cut off */
        #summary-container {
            overflow-y: visible; /* Allows html2canvas to capture full content */
            max-height: none;
        }
        /* Re-style for screen view */
        @media screen {
            #summary-container {
                max-height: 24rem; /* 96 * 0.25rem = 384px */
                overflow-y: auto;
            }
        }
        /* Mini-spinner for explanation */
        .mini-spinner {
            width: 20px;
            height: 20px;
            border: 2px solid #f3f3f3;
            border-top: 2px solid #4f46e5;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin: 1rem auto;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        /* NEW: Styles for PDF page range inputs */
        .page-range-input {
            width: 60px;
            padding: 4px 8px;
            border: 1px solid #ddd;
            border-radius: 6px;
            text-align: center;
        }
    </style>
</head>
<body class="bg-gray-100 text-gray-800 flex items-center justify-center min-h-screen p-4">

    <!-- API Key Modal -->
    <div id="api-key-modal" class="hidden fixed inset-0 flex items-center justify-center modal-backdrop">
        <div class="bg-white p-8 rounded-2xl shadow-2xl w-full max-w-md m-4 modal fade-in">
            <h2 class="text-2xl font-bold text-gray-800 mb-4">Enter Your API Key</h2>
            <p class="text-gray-600 mb-6">To generate questions, please provide your Gemini API key. It will only be stored for this session.</p>
            <input type="password" id="api-key-input" class="w-full px-4 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-indigo-500" placeholder="Paste your API key here">
            <button id="save-api-key-btn" class="mt-6 w-full bg-indigo-600 text-white font-bold py-3 px-6 rounded-lg shadow-md hover:bg-indigo-700 transition duration-300">
                Save and Continue
            </button>
        </div>
    </div>


    <div id="app-container" class="w-full max-w-2xl mx-auto">
        <!-- Persistent Header -->
        <header id="app-header" class="flex justify-center items-center gap-4 mb-6">
            <!-- IMPORTANT: Replace the src below with the path to your college's logo.jpeg file -->
            <img src="logo.png" alt="College Logo" class="w-20 h-20 object-cover rounded-full">
            <div>
                <h1 class="text-3xl font-bold text-gray-800">AI Self-Analysis Tool</h1>
                <p class="text-gray-500 font-medium">Sankaralingam Bhuvaneshwari College Of Pharmacy,Sivakasi</p>
            </div>
        </header>

        <!-- NEW: Student Info Section -->
        <div id="student-info-section" class="hidden bg-white p-8 rounded-2xl shadow-lg text-center fade-in">
            <h2 class="text-2xl font-bold text-gray-800 mb-4">Student Details (Optional)</h2>
            <p class="text-gray-600 mb-6">You can enter your name and semester to include in your quiz summary.</p>
            <div class="space-y-4">
                <input type="text" id="student-name" class="w-full px-4 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-indigo-500" placeholder="Enter your name">
                <input type="text" id="student-semester" class="w-full px-4 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-indigo-500" placeholder="Enter your semester">
            </div>
            <div class="flex gap-4 mt-6">
                <button id="skip-info-btn" class="w-full bg-gray-500 text-white font-bold py-3 px-6 rounded-lg shadow-md hover:bg-gray-600 transition duration-300">
                    Skip
                </button>
                <button id="continue-to-upload-btn" class="w-full bg-indigo-600 text-white font-bold py-3 px-6 rounded-lg shadow-md hover:bg-indigo-700 transition duration-300">
                    Continue
                </button>
            </div>
        </div>

        <!-- Upload Section (now hidden initially) -->
        <div id="upload-section" class="hidden bg-white p-8 rounded-2xl shadow-lg text-center fade-in">
            <p class="text-gray-600 mb-6">Upload your study materials (PDFs, images) to start the quiz.</p>
            <div class="mb-4">
                <input type="file" id="file-input" multiple class="hidden" accept=".pdf,.png,.jpg,.jpeg,.webp">
                <label for="file-input" class="file-input-label inline-block bg-indigo-600 text-white font-semibold py-3 px-6 rounded-lg shadow-md hover:bg-indigo-700">
                    Select Files
                </label>
            </div>
            <!-- NEW: File list now renders richer UI -->
            <div id="file-list" class="text-gray-500 text-sm text-left space-y-2"></div>
            <div id="preload-status" class="text-indigo-600 font-medium text-sm mt-4 h-5"></div> <!-- Preload status message -->
            <button id="start-quiz-btn" class="mt-6 w-full bg-green-500 text-white font-bold py-3 px-6 rounded-lg shadow-md hover:bg-green-600 transition duration-300 disabled:bg-gray-400 disabled:cursor-not-allowed" disabled>
                Process Files & Start Quiz
            </button>
        </div>

        <!-- Quiz Section -->
        <div id="quiz-section" class="hidden fade-in">
            <div class="bg-white p-8 rounded-2xl shadow-lg">
                <!-- NEW: Student Info Display during quiz -->
                <div id="quiz-student-info" class="hidden pb-4 mb-4 border-b border-gray-200">
                    <!-- Content will be populated by JS -->
                </div>
                
                <!-- RESTRUCTURED: Timer and Score moved to the right -->
                <div class="flex justify-between items-start mb-4">
                    <h2 class="text-xl font-bold text-indigo-600">Question <span id="question-count">1</span></h2>
                    <div class="text-right">
                        <div class="text-lg font-semibold text-gray-600">Time Taken: <span id="timer-display" class="text-gray-900">0</span>s</div>
                        <div class="text-lg font-semibold">Score: <span id="score-display">0</span></div>
                    </div>
                </div>
                <div id="question-container" class="mb-6 min-h-[80px]">
                    <p id="question-text" class="text-lg text-gray-700"></p>
                </div>
                <div id="options-container" class="grid grid-cols-1 md:grid-cols-2 gap-4">
                    <!-- Options will be generated here -->
                </div>
                <div id="feedback-container" class="mt-6 text-center font-medium min-h-[24px]"></div>
                
                <!-- NEW Explanation Section -->
                <div id="explanation-container" class="hidden mt-4 p-4 bg-indigo-50 border border-indigo-200 rounded-lg text-gray-700">
                    <!-- Explanation content will go here -->
                </div>
                
                <div class="flex gap-4">
                    <button id="explain-answer-btn" class="hidden mt-4 w-full bg-blue-500 text-white font-bold py-3 px-4 rounded-lg shadow-md hover:bg-blue-600 transition duration-300">
                        ✨ Explain This Answer
                    </button>
                    <button id="next-question-btn" class="hidden mt-4 w-full bg-indigo-500 text-white font-bold py-3 px-4 rounded-lg shadow-md hover:bg-indigo-600 transition duration-300">
                        Next Question
                    </button>
                </div>
            </div>
            <button id="end-quiz-btn" class="mt-6 w-full bg-red-500 text-white font-bold py-3 px-6 rounded-lg shadow-md hover:bg-red-600 transition duration-300">
                End Quiz
            </button>
        </div>

        <!-- Result Section -->
        <div id="result-section" class="hidden fade-in">
             <div class="bg-white p-8 rounded-2xl shadow-lg text-center">
                <!-- NEW: Student Info Display -->
                <div id="student-summary-info" class="hidden text-left"></div>

                <h1 class="text-3xl font-bold text-gray-800 mb-2">Quiz Complete!</h1>
                <p class="text-gray-600 mb-6">Here's your final score✨:</p>
                
                <!-- Motivation Section -->
                <div id="motivation-container" class="mb-6 min-h-[160px]">
                    <div id="lottie-animation" class="w-32 h-32 mx-auto"></div>
                    <p id="motivation-text" class="text-lg font-medium text-gray-700 mt-2"></p>
                </div>

                <div class="bg-indigo-100 text-indigo-800 rounded-lg p-6 mb-8">
                    <p class="text-xl">Final Score</p>
                    <p class="text-5xl font-extrabold my-2" id="final-score">0 / 0</p>
                    <p class="text-2xl font-bold" id="final-percentage">0%</p>
                </div>

                <!-- NEW Key Concepts Section -->
                <div id="key-concepts-section" class="text-left mb-8">
                    <button id="generate-summary-btn" class="w-full bg-green-600 text-white font-bold py-3 px-6 rounded-lg shadow-md hover:bg-green-700 transition duration-300">
                        ✨ Generate Key Concepts
                    </button>
                    <div id="key-concepts-container" class="hidden mt-4 p-4 bg-green-50 border border-green-200 rounded-lg text-gray-700">
                        <!-- Key concepts will go here -->
                    </div>
                </div>
                
                <!-- Summary Section -->
                <div id="summary-section" class="text-left">
                    <h2 class="text-2xl font-bold text-gray-800 mb-4">Review Your Answers</h2>
                    <div id="summary-container" class="space-y-6 pr-2 border border-gray-200 rounded-lg p-4">
                        <!-- Summary items will be injected here -->
                    </div>
                </div>

                <div class="grid grid-cols-1 md:grid-cols-2 gap-4 mt-8">
                    <button id="export-pdf-btn" class="w-full bg-gray-700 text-white font-bold py-3 px-6 rounded-lg shadow-md hover:bg-gray-800 transition duration-300">
                        Export as PDF
                    </button>
                    <button id="restart-btn" class="w-full bg-indigo-600 text-white font-bold py-3 px-6 rounded-lg shadow-md hover:bg-indigo-700 transition duration-300">
                        Start a New Quiz
                    </button>
                </div>
            </div>
        </div>

        <!-- Loader -->
        <div id="loader" class="hidden fixed inset-0 bg-gray-900 bg-opacity-50 flex items-center justify-center z-50">
            <div class="bg-white p-8 rounded-2xl shadow-lg text-center w-full max-w-sm m-4">
                <div id="loader-spinner" class="animate-spin rounded-full h-16 w-16 border-t-4 border-b-4 border-indigo-500 mx-auto"></div>
                <p id="loader-main-text" class="mt-4 text-lg font-semibold text-gray-700">Your AI is thinking...</p>
                <p id="loader-sub-text" class="text-gray-500">Generating a unique question from your documents.</p>
            </div>
        </div>
    </div>

<script>
    const { jsPDF } = window.jspdf;
    // NEW: PDF.js setup
    if (typeof pdfjsLib === 'undefined') {
        console.error("pdf.js library is not loaded!");
    } else {
        pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';
    }

    // Section Elements
    const studentInfoSection = document.getElementById('student-info-section');
    const uploadSection = document.getElementById('upload-section');
    const quizSection = document.getElementById('quiz-section');
    const resultSection = document.getElementById('result-section');
    const appHeader = document.getElementById('app-header');

    // Student Info Elements
    const studentNameInput = document.getElementById('student-name');
    const studentSemesterInput = document.getElementById('student-semester');
    const continueToUploadBtn = document.getElementById('continue-to-upload-btn');
    const skipInfoBtn = document.getElementById('skip-info-btn');

    // Upload Elements
    const fileInput = document.getElementById('file-input');
    const fileList = document.getElementById('file-list');
    const preloadStatus = document.getElementById('preload-status');
    const startQuizBtn = document.getElementById('start-quiz-btn');

    // Button Elements
    const endQuizBtn = document.getElementById('end-quiz-btn');
    const restartBtn = document.getElementById('restart-btn');
    const exportPdfBtn = document.getElementById('export-pdf-btn');
    const explainAnswerBtn = document.getElementById('explain-answer-btn');
    const nextQuestionBtn = document.getElementById('next-question-btn');
    const generateSummaryBtn = document.getElementById('generate-summary-btn');
    
    // Loader Elements
    const loader = document.getElementById('loader');
    const loaderSpinner = document.getElementById('loader-spinner');
    const loaderMainText = document.getElementById('loader-main-text');
    const loaderSubText = document.getElementById('loader-sub-text');

    // API Key Modal elements
    const apiKeyModal = document.getElementById('api-key-modal');
    const apiKeyInput = document.getElementById('api-key-input');
    const saveApiKeyBtn = document.getElementById('save-api-key-btn');

    // Quiz elements
    const questionCountDisplay = document.getElementById('question-count');
    const scoreDisplay = document.getElementById('score-display');
    const timerDisplay = document.getElementById('timer-display');
    const questionText = document.getElementById('question-text');
    const optionsContainer = document.getElementById('options-container');
    const feedbackContainer = document.getElementById('feedback-container');
    const explanationContainer = document.getElementById('explanation-container');

    // Result elements
    const studentSummaryInfo = document.getElementById('student-summary-info');
    const motivationContainer = document.getElementById('motivation-container');
    const lottieAnimation = document.getElementById('lottie-animation');
    const motivationText = document.getElementById('motivation-text');
    const finalScoreDisplay = document.getElementById('final-score');
    const finalPercentageDisplay = document.getElementById('final-percentage');
    const summaryContainer = document.getElementById('summary-container');
    const keyConceptsContainer = document.getElementById('key-concepts-container');

    // State variables
    let studentName = "";
    let studentSemester = "";
    let globalFilesData = []; // NEW: { file, numPages, startPage, endPage, data, mimeType, status }
    let filesContent = []; // This will hold {text} or {inlineData} for Gemini
    let currentQuestionData = null;
    let score = 0;
    let totalQuestions = 0;
    let attempts = 0;
    let questionHistory = []; // { question, options, correctIdx, selectedIdx, timeTaken }
    let loaderTimer5s = null;
    let loaderTimer10s = null;
    let currentLottie;
    let questionTimerInterval = null;
    let questionStartTime = 0;
    let questionBuffer = [];
    let isFetching = false;
    const MAX_BUFFER_SIZE = 3;
    const globalTimeout = 60000; // Hardcoded 60s
    
    // NEW: Sleep helper for exponential backoff
    const sleep = (ms) => new Promise(resolve => setTimeout(resolve, ms));

    const congratulatoryMessages = [
        "Brilliant! You're on fire!", "Wow, you're a genius! Nailed it!", "Stunning! You've got this down.",
        "Correct! Are you sure you didn't write the textbook?", "Perfect! That's exactly right.",
        "You're on a roll! Keep it up!", "Excellent work! You're a star!"
    ];

    const encouragementMessages = [
        "Not quite, but don't give up! The next one is yours.", "Close! Every attempt is a step forward.",
        "That was a tricky one. You'll get it next time!", "Don't worry, learning is a journey. Keep pushing!",
        "Mistakes are proof that you are trying. Let's go again!"
    ];

    // --- INITIALIZATION ---
    document.addEventListener('DOMContentLoaded', initApiKey);

    function initApiKey() {
        if (!sessionStorage.getItem('gemini-api-key')) {
            apiKeyModal.classList.remove('hidden');
        } else {
            // If key exists, show info section instead of modal
            studentInfoSection.classList.remove('hidden');
        }
    }

    saveApiKeyBtn.addEventListener('click', () => {
        const apiKey = apiKeyInput.value.trim();
        if (apiKey) {
            sessionStorage.setItem('gemini-api-key', apiKey);
            apiKeyModal.classList.add('hidden');
            // Show info section after saving key
            studentInfoSection.classList.remove('hidden');
        } else {
            alert('Please enter a valid API key.');
        }
    });

    // --- NEW: Student Info Handling ---
    continueToUploadBtn.addEventListener('click', () => {
        studentName = studentNameInput.value.trim();
        studentSemester = studentSemesterInput.value.trim();
        studentInfoSection.classList.add('hidden');
        uploadSection.classList.remove('hidden');
    });

    skipInfoBtn.addEventListener('click', () => {
        studentName = "";
        studentSemester = "";
        studentNameInput.value = "";
        studentSemesterInput.value = "";
        studentInfoSection.classList.add('hidden');
        uploadSection.classList.remove('hidden');
    });

    // --- NEW: Advanced FILE HANDLING & PDF Processing ---
    fileInput.addEventListener('change', async () => {
        if (fileInput.files.length === 0) {
            fileList.innerHTML = '';
            preloadStatus.innerHTML = '';
            startQuizBtn.disabled = true;
            return;
        }

        preloadStatus.textContent = 'Processing files...';
        startQuizBtn.disabled = true;
        fileList.innerHTML = ''; // Clear previous list
        globalFilesData = []; // Reset global data

        const files = Array.from(fileInput.files);
        let filesProcessed = 0;

        files.forEach((file, index) => {
            const fileData = {
                file: file,
                numPages: null,
                startPage: 1,
                endPage: null,
                data: null, // This will hold ArrayBuffer for PDF, DataURL for image
                mimeType: file.type,
                status: 'processing'
            };
            globalFilesData.push(fileData);
            
            const reader = new FileReader();

            if (file.type === 'application/pdf') {
                reader.onload = async (e) => {
                    try {
                        const arrayBuffer = e.target.result;
                        // Store the original buffer. We will make copies for processing
                        // to prevent "detached ArrayBuffer" errors.
                        globalFilesData[index].data = arrayBuffer; 
                        
                        // Create a copy for the metadata call
                        const bufferCopy = arrayBuffer.slice(0); 
                        
                        const pdfDoc = await pdfjsLib.getDocument({ data: bufferCopy }).promise;
                        globalFilesData[index].numPages = pdfDoc.numPages;
                        globalFilesData[index].endPage = pdfDoc.numPages;
                        globalFilesData[index].status = 'processed';
                    } catch (err) {
                        console.error("Error processing PDF:", err);
                        globalFilesData[index].status = 'error';
                    }
                    filesProcessed++;
                    renderFileList();
                    checkAllFilesProcessed(files.length, filesProcessed);
                };
                reader.readAsArrayBuffer(file);

            } else if (file.type.startsWith('image/')) {
                reader.onload = (e) => {
                    globalFilesData[index].data = e.target.result; // Data URL
                    globalFilesData[index].status = 'processed';
                    filesProcessed++;
                    renderFileList();
                    checkAllFilesProcessed(files.length, filesProcessed);
                };
                reader.readAsDataURL(file);

            } else {
                console.warn(`Unsupported file type: ${file.name}`);
                globalFilesData[index].status = 'error';
                filesProcessed++;
                renderFileList();
                checkAllFilesProcessed(files.length, filesProcessed);
            }
        });
    });

    function checkAllFilesProcessed(totalFiles, filesProcessed) {
        if (totalFiles === filesProcessed) {
            preloadStatus.textContent = 'Files are ready to be processed.';
            startQuizBtn.disabled = false;
        }
    }

    function renderFileList() {
        fileList.innerHTML = '';
        globalFilesData.forEach((fileData, index) => {
            const fileItemDiv = document.createElement('div');
            fileItemDiv.classList.add('p-2', 'border', 'rounded-md', 'bg-gray-50');
            
            let content = '';
            if (fileData.status === 'processing') {
                content = `<span>Processing: ${fileData.file.name}...</span>`;
            } else if (fileData.status === 'error') {
                content = `<span class="text-red-500">Error processing: ${fileData.file.name}</span>`;
            } else if (fileData.mimeType === 'application/pdf') {
                content = `
                    <div class="font-medium">${fileData.file.name} (${fileData.numPages} pages)</div>
                    <div class="flex items-center gap-2 mt-1">
                        <label class="text-sm">Page Range:</label>
                        <input type="number" min="1" max="${fileData.numPages}" value="1" data-index="${index}" data-type="start" class="page-range-input">
                        <span class="text-sm">to</span>
                        <input type="number" min="1" max="${fileData.numPages}" value="${fileData.numPages}" data-index="${index}" data-type="end" class="page-range-input">
                    </div>
                `;
            } else if (fileData.mimeType.startsWith('image/')) {
                content = `<span class="font-medium">Image: ${fileData.file.name}</span>`;
            }
            
            fileItemDiv.innerHTML = content;
            fileList.appendChild(fileItemDiv);
        });

        // Add event listeners to new inputs
        document.querySelectorAll('.page-range-input').forEach(input => {
            input.addEventListener('change', (e) => {
                const index = parseInt(e.target.dataset.index);
                const type = e.target.dataset.type;
                let value = parseInt(e.target.value);
                const maxPages = globalFilesData[index].numPages;

                // Validate
                if (value < 1) value = 1;
                if (value > maxPages) value = maxPages;
                e.target.value = value; // Correct input field

                if (type === 'start') {
                    globalFilesData[index].startPage = value;
                    // Ensure start is not after end
                    if (value > globalFilesData[index].endPage) {
                        globalFilesData[index].endPage = value;
                        // Find and update the 'end' input field
                        document.querySelector(`.page-range-input[data-index="${index}"][data-type="end"]`).value = value;
                    }
                } else {
                    globalFilesData[index].endPage = value;
                    // Ensure end is not before start
                    if (value < globalFilesData[index].startPage) {
                        globalFilesData[index].startPage = value;
                        // Find and update the 'start' input field
                        document.querySelector(`.page-range-input[data-index="${index}"][data-type="start"]`).value = value;
                    }
                }
            });
        });
    }

    // NEW: Function to process files for Gemini API
    async function processFilesForGemini() {
        filesContent = []; // Clear previous content
        for (const fileData of globalFilesData) {
            if (fileData.status !== 'processed') continue;

            if (fileData.mimeType.startsWith('image/')) {
                const base64String = fileData.data.split(',')[1];
                filesContent.push({ inlineData: { data: base64String, mimeType: fileData.mimeType } });
            
            } else if (fileData.mimeType === 'application/pdf') {
                let extractedText = `--- START OF PDF: ${fileData.file.name} (Pages ${fileData.startPage} to ${fileData.endPage}) ---\n\n`;
                try {
                    // Create a NEW copy of the buffer for this processing call.
                    // This is the fix for the "detached ArrayBuffer" error.
                    const bufferCopy = fileData.data.slice(0);
                    const pdfDoc = await pdfjsLib.getDocument({ data: bufferCopy }).promise;
                    
                    for (let i = fileData.startPage; i <= fileData.endPage; i++) {
                        // Ensure page number is valid
                        if (i > pdfDoc.numPages || i < 1) continue; 
                        
                        const page = await pdfDoc.getPage(i);
                        const textContent = await page.getTextContent();
                        const pageText = textContent.items.map(item => item.str).join(' ');
                        extractedText += `[Page ${i}]\n${pageText}\n\n`;
                    }
                    extractedText += `--- END OF PDF: ${fileData.file.name} ---\n`;
                    filesContent.push({ text: extractedText });
                } catch (err) {
                    console.error(`Failed to extract text from ${fileData.file.name}:`, err);
                    throw new Error(`Failed to extract text from PDF. ${err.message}`);
                }
            }
        }
    }


    // --- QUIZ LOGIC ---
    startQuizBtn.addEventListener('click', async () => {
        showLoader(true, "Processing selected pages...");
        try {
            await processFilesForGemini();
        } catch (error) {
            showLoader(false);
            preloadStatus.textContent = error.message;
            return;
        }
        
        if (filesContent.length === 0) {
            showLoader(false);
            preloadStatus.textContent = "No valid files or pages were processed. Please check your selection.";
            return;
        }

        uploadSection.classList.add('hidden');
        quizSection.classList.remove('hidden');
        appHeader.classList.remove('hidden');
        
        // NEW: Populate student info in quiz header
        const quizStudentInfo = document.getElementById('quiz-student-info');
        if (studentName || studentSemester) {
            let infoHtml = '';
            if (studentName) infoHtml += `<p class="text-sm text-gray-600"><strong>Name:</strong> ${studentName}</p>`;
            if (studentSemester) infoHtml += `<p class="text-sm text-gray-600"><strong>Semester:</strong> ${studentSemester}</p>`;
            quizStudentInfo.innerHTML = infoHtml;
            quizStudentInfo.classList.remove('hidden');
        } else {
            quizStudentInfo.classList.add('hidden');
        }

        resetQuiz();
        
        showLoader(true, "Generating first question...");
        try {
            const firstQuestion = await fetchQuestionData();
            if (firstQuestion) {
                displayQuestion(firstQuestion);
                fillQuestionBuffer(); // Start background loading for Q2
            } else {
                handleFetchError(new Error("Failed to load the first question."));
            }
        } catch (error) {
            handleFetchError(error);
        } finally {
            showLoader(false);
        }
    });
    
    endQuizBtn.addEventListener('click', showResults);
    
    nextQuestionBtn.addEventListener('click', async () => {
        nextQuestionBtn.classList.add('hidden');
        explainAnswerBtn.classList.add('hidden');
        explanationContainer.classList.add('hidden');
        explanationContainer.innerHTML = ''; // Clear old explanation

        if (questionBuffer.length > 0) {
            // If we have a question ready, display it instantly
            const nextQuestion = questionBuffer.shift();
            displayQuestion(nextQuestion);
            fillQuestionBuffer(); // Start refilling
        } else {
            // User is too fast, buffer is empty. Fetch one manually.
            showLoader(true, "Fetching next question...");
            try {
                const nextQuestion = await fetchQuestionData();
                if (nextQuestion) {
                    displayQuestion(nextQuestion);
                } else {
                    handleFetchError(new Error("Failed to load the next question."));
                }
                fillQuestionBuffer(); // Start refilling now that we're empty
            } catch (error) {
                 console.error("Failed to display question:", error);
                 handleFetchError(error);
            } finally {
                showLoader(false);
            }
        }
    });
    
    restartBtn.addEventListener('click', () => {
        if(currentLottie) currentLottie.destroy();
        resultSection.classList.add('hidden');
        // Go back to student info section instead of upload
        studentInfoSection.classList.remove('hidden');
        
        // Reset file input and state
        fileInput.value = '';
        fileList.innerHTML = '';
        preloadStatus.innerHTML = '';
        startQuizBtn.disabled = true;

        // Clear student info inputs
        studentNameInput.value = "";
        studentSemesterInput.value = "";
    });

    // --- PDF EXPORT ---
    exportPdfBtn.addEventListener('click', () => {
        // NEW: Prompt for file name
        const defaultName = `ai-quiz-summary${studentName ? '-' + studentName.replace(/\s/g, '_') : ''}`;
        const fileName = window.prompt("Enter a file name for your PDF:", defaultName);

        if (fileName === null) {
            return; // User cancelled the prompt
        }
        
        showLoader(true, "Preparing PDF... This may take a few seconds.", false); // Show loader without spinner
        
        // UPDATED: Delay to allow CHTML to render reliably
        setTimeout(() => {
            // Temporarily make all content visible for capture
            const summary = document.getElementById('summary-container');
            const keyConcepts = document.getElementById('key-concepts-container');
            summary.style.maxHeight = 'none';
            summary.style.overflowY = 'visible';
            
            // We need to capture the whole results block
            const resultsToCapture = document.getElementById('result-section');

            html2canvas(resultsToCapture, {
                scale: 2, // Higher scale for better quality
                useCORS: true,
                onclone: (doc) => {
                    // Ensure hidden-by-default content is visible in the clone
                    const clonedKeyConcepts = doc.getElementById('key-concepts-container');
                    if (clonedKeyConcepts.classList.contains('hidden')) {
                        clonedKeyConcepts.style.display = 'none'; // Keep hidden if not generated
                    }
                    // Also check student info
                    const clonedStudentInfo = doc.getElementById('student-summary-info');
                    if (clonedStudentInfo.classList.contains('hidden')) {
                        clonedStudentInfo.style.display = 'none';
                    }
                }
            }).then(canvas => {
                // Restore screen styles
                summary.style.maxHeight = '24rem';
                summary.style.overflowY = 'auto';

                const imgData = canvas.toDataURL('image/png');
                const pdf = new jsPDF('p', 'mm', 'a4');
                const pdfWidth = pdf.internal.pageSize.getWidth();
                const pdfHeight = pdf.internal.pageSize.getHeight();
                
                const canvasWidth = canvas.width;
                const canvasHeight = canvas.height;
                const canvasAspectRatio = canvasHeight / canvasWidth;
                
                const imgWidth = pdfWidth;
                const imgHeight = imgWidth * canvasAspectRatio;

                let heightLeft = imgHeight;
                let position = 0;
                const margin = 10; // Add a small margin
                
                const effectivePageWidth = pdfWidth - (margin * 2);
                const effectivePageHeight = pdfHeight - (margin * 2);
                const effectiveImgHeight = effectivePageWidth * canvasAspectRatio;

                pdf.addImage(imgData, 'PNG', margin, margin, effectivePageWidth, effectiveImgHeight);
                heightLeft -= effectivePageHeight;

                while (heightLeft > 0) {
                    position -= effectivePageHeight; // Move the image "up" on the next page
                    pdf.addPage();
                    pdf.addImage(imgData, 'PNG', margin, position + margin, effectivePageWidth, effectiveImgHeight);
                    heightLeft -= effectivePageHeight;
                }
                
                // NEW: Use the user-provided file name
                const finalFileName = fileName.trim() === "" ? defaultName : fileName.trim();
                pdf.save(finalFileName + '.pdf');
                
                showLoader(false);
            }).catch(err => {
                console.error("Error generating PDF:", err);
                // Restore styles even if error
                summary.style.maxHeight = '24rem';
                summary.style.overflowY = 'auto';
                showLoader(false);
                alert("Sorry, there was an error creating the PDF.");
            });
        }, 1500); // 1.5-second delay for CHTML rendering
    });


    function resetQuiz() {
        score = 0;
        totalQuestions = 0;
        scoreDisplay.textContent = score;
        questionCountDisplay.textContent = totalQuestions + 1;
        summaryContainer.innerHTML = '';
        keyConceptsContainer.innerHTML = '';
        keyConceptsContainer.classList.add('hidden');
        generateSummaryBtn.disabled = false;
        generateSummaryBtn.textContent = '✨ Generate Key Concepts';
        if(currentLottie) currentLottie.destroy();
        if(questionTimerInterval) clearInterval(questionTimerInterval);
    }

    // --- NEW GEMINI API FUNCTIONS ---

    /**
     * Extracts a JSON object from a string that might contain other text.
     * @param {string} str The string to parse.
     * @returns {string | null} The extracted JSON string, or null if not found.
     */
    function extractJson(str) {
        // 1. Try to find ```json ... ``` block
        const jsonMatch = str.match(/```json\s*([\s\S]*?)\s*```/);
        if (jsonMatch && jsonMatch[1]) {
            return jsonMatch[1];
        }
        
        // 2. Fallback: find the first '{' and last '}'
        const firstBrace = str.indexOf('{');
        const lastBrace = str.lastIndexOf('}');
        if (firstBrace !== -1 && lastBrace !== -1 && lastBrace > firstBrace) {
            return str.substring(firstBrace, lastBrace + 1);
        }

        console.warn("Could not find valid JSON markers in text.");
        return null; // Return null if no JSON object is found
    }

    // --- UPDATED callGemini with Exponential Backoff ---
    async function callGemini(systemPrompt, userPrompt, useFiles = true, jsonResponse = false) {
        const apiKey = sessionStorage.getItem('gemini-api-key');
        if (!apiKey) {
            throw new Error("API key not valid. Please refresh and enter your key.");
        }

        const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-09-2025:generateContent?key=${apiKey}`;
        
        const payload = {
            contents: [{ 
                role: "user", 
                parts: [
                    { text: userPrompt }, 
                    ...(useFiles ? filesContent : []) // Spread the processed file content
                ] 
            }],
            systemInstruction: { parts: [{ text: systemPrompt }] },
        };

        if (jsonResponse) {
            payload.generationConfig = {
                responseMimeType: "application/json",
                responseSchema: {
                    type: "OBJECT",
                    properties: {
                        question: { type: "STRING" },
                        options: { type: "ARRAY", items: { type: "STRING" }, minItems: 4, maxItems: 4 },
                        correctAnswerIndex: { type: "INTEGER", minimum: 0, maximum: 3 }
                    },
                    required: ["question", "options", "correctAnswerIndex"]
                }
            };
        }
        
        // NEW: Exponential Backoff Settings
        const maxRetries = 7; // Increased from 5
        let delay = 3000; // Increased from 2000ms

        for (let attempt = 0; attempt < maxRetries; attempt++) {
            // Add timeout controller FOR THIS ATTEMPT
            const controller = new AbortController();
            const timeoutId = setTimeout(() => controller.abort(), globalTimeout); // 60-second timeout
            let text = "";
            let error;

            try {
                const response = await fetch(apiUrl, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload),
                    signal: controller.signal // Pass the AbortSignal
                });

                clearTimeout(timeoutId); // Clear the timeout if the fetch succeeds

                if (!response.ok) {
                    const errorBody = await response.json().catch(() => ({}));
                    const errorMessage = errorBody?.error?.message || `API request failed with status ${response.status}`;
                    
                    // Check for retryable HTTP status (5xx errors)
                    if (response.status >= 500 && response.status <= 599) {
                         // e.g., 500, 503 Service Unavailable (which "overloaded" might be)
                         error = new Error(errorMessage);
                         // Don't throw, let it fall through to the retry logic below
                    } else {
                        // Not a retryable server error (e.g., 400, 403, 429)
                        throw new Error(errorMessage); // Throw immediately
                    }
                }

                if (!error) { // If no error was flagged above (i.e., response.ok)
                    const result = await response.json();
                    text = result.candidates?.[0]?.content?.parts?.[0]?.text;

                    if (!text) {
                        throw new Error("No content received from API. The model may have refused to answer.");
                    }
                
                    // --- SUCCESS ---
                    // Handle JSON extraction
                    if (jsonResponse) {
                        const jsonText = extractJson(text);
                        if (!jsonText) {
                            console.error("Failed to extract JSON from response:", text);
                            throw new Error("AI returned a response, but it was not in the expected format.");
                        }
                        return jsonText; // SUCCESSFUL RETURN
                    }
                    
                    return text; // SUCCESSFUL RETURN
                    // --- END SUCCESS ---
                }

            } catch (err) {
                clearTimeout(timeoutId); // Ensure timeout is cleared on other errors too
                error = err; // Store the error
            }

            // --- If we are here, an error occurred ---
            
            // Check if it's the last attempt
            if (attempt === maxRetries - 1) {
                // If this was the last try, re-throw the last error we got
                if (error.name === 'AbortError') {
                    throw new Error("The AI request timed out. Please try again.");
                }
                throw error;
            }

            // Check if error is retryable
            const isRetryable = (error.name === 'AbortError') || 
                                (error.message.includes("Failed to fetch")) ||
                                (error.message.includes("overloaded")) ||
                                (error.message.includes("500") || error.message.includes("503")); // Check for 5xx errors

            if (isRetryable) {
                console.warn(`AI request attempt ${attempt + 1} failed (${error.message}). Retrying in ${delay / 1000}s...`);
                await sleep(delay);
                delay *= 2; // Exponential backoff
            } else {
                // Not a retryable error (e.g., API key, bad request), throw immediately
                throw error;
            }
        }
    }
    // --- END UPDATED callGemini ---


    // --- REVISED: Question Buffer Function ---
    async function fillQuestionBuffer() {
        if (isFetching) return; // Don't run if already fetching
        isFetching = true;
        
        try {
            // Keep fetching until buffer is full
            while (questionBuffer.length < MAX_BUFFER_SIZE) {
                console.log(`Buffer has ${questionBuffer.length}/${MAX_BUFFER_SIZE}. Fetching new question...`);
                const questionData = await fetchQuestionData();
                if (questionData) {
                    // Check for duplicates before adding
                    if (!questionHistory.some(q => q.question === questionData.question) && !questionBuffer.some(q => q.question === questionData.question)) {
                         questionBuffer.push(questionData);
                    } else {
                        console.warn("Duplicate question detected and skipped.");
                    }
                }
            }
            console.log("Question buffer is full.");
        } catch (error) {
            console.error("Error filling question buffer:", error.message);
        } finally {
            isFetching = false;
        }
    }


    async function fetchQuestionData() {
        attempts = 0;
        feedbackContainer.innerHTML = '';

        // **REINFORCED** system prompt for symbol spacing
        const systemPrompt = `You are an AI quiz master. Based on the provided document(s) (which could be images or text extracted from PDF pages), generate a single, unique, multiple-choice question with four options. Return the result in a strict JSON format.
RULES:
1. Ensure the question is relevant. The options should be plausible but only one is correct.
2. NEVER start the question with phrases like 'According to the provided text', 'Based on the provided data', or 'According to the document'.
3. If you use mathematical or scientific notation, use standard LaTeX format (e.g., $...$).
4. ABSOLUTELY CRITICAL: You MUST combine scientific symbols and their units *inside* the SAME LaTeX block. NEVER add a space between a symbol and its unit.
   - CORRECT: \`10 $\mu$m\`
   - CORRECT: \`($\mu$g)\`
   - CORRECT: \`5000 $\mu$m\`
   
   - HORRIBLY WRONG (DO NOT DO THIS): \`10 $\mu$ m\`
   - HORRIBLY WRONG (DO NOT DO THIS): \`($\mu$ g)\`
   - HORRIBLY WRONG (DO NOT DO THIS): \`Separation of $\mu$ \n g of the substances.\` (This creates an ugly line break).
   - The correct version of the above is: \`Separation of $\mu$g of the substances.\`

5. VITAL: Do NOT add extra text or newlines inside or around symbols. Use standard LaTeX only.
   - WRONG: \`( extCOOH )\`
   - RIGHT: \`( $COOH$ )\`
   - WRONG: \`90 \n 0\` (This is not 90 degrees)
   - RIGHT: \`90$^\circ$\`
   - WRONG: \`F \n )\` or \`C \n )\` (Putting symbols on new lines)
   - RIGHT: \`( $F$ )\` and \`( $C$ )\`
   - WRONG: \`$\lambda$ \n and an increase\`
   - RIGHT: \`$\lambda$ and an increase\`
   - WRONG: \`( \n K \n )\` or \`( \n Na \n )\`
   - RIGHT: \`( $K$ )\` or \`( $Na$ )\`
6. Only output the raw JSON object, starting with { and ending with }. Do not add any other text or markdown wrappers.
7. CRITICAL: All four 'options' MUST be unique. Do not generate duplicate options, even if they look similar.`;
        
        // Get history from both answered questions and the current buffer
        const answeredQuestions = questionHistory.map(q => q.question);
        const bufferedQuestions = questionBuffer.map(q => q.question);
        const allKnownQuestions = [...answeredQuestions, ...bufferedQuestions];
        
        const userPrompt = `Generate one new multiple-choice question from the content. Avoid questions similar to these, which have already been asked: ${JSON.stringify(allKnownQuestions)}`;
        
        let jsonText = "";
        try {
            jsonText = await callGemini(systemPrompt, userPrompt, true, true);
            return JSON.parse(jsonText);
        } catch (error) {
            console.error("Failed to parse JSON:", error, "Received text:", jsonText);
            // Re-throw a more user-friendly error
            throw new Error(`Failed to read AI response: ${error.message}`);
        }
    }
    
    // NEW: Fetch Explanation
    explainAnswerBtn.addEventListener('click', async () => {
        explanationContainer.innerHTML = '<div class="mini-spinner"></div>';
        explanationContainer.classList.remove('hidden');
        explainAnswerBtn.disabled = true;

        // **REINFORCED** system prompt for symbol spacing
        const systemPrompt = `You are an expert tutor. Based on the provided documents (images or text from PDFs), explain why the correct answer is right and why the other options are wrong for the given question.
RULES:
1. Use Markdown for formatting.
2. If you use mathematical or scientific notation, use standard LaTeX format (e.g., $...$).
3. ABSOLUTELY CRITICAL: You MUST combine scientific symbols and their units *inside* the SAME LaTeX block. NEVER add a space between a symbol and its unit.
   - CORRECT: \`10 $\mu$m\`
   - CORRECT: \`($\mu$g)\`
   - HORRIBLY WRONG (DO NOT DO THIS): \`10 $\mu$ m\`
   - HORRIBLY WRONG (DO NOT DO THIS): \`($\mu$ g)\`
   - HORRIBLY WRONG (DO NOT DO THIS): \`Separation of $\mu$ \n g of the substances.\`
   - The correct version of the above is: \`Separation of $\mu$g of the substances.\`

4. VITAL: Do NOT add extra text or newlines inside or around symbols.
   - WRONG: \`( extCOOH )\`
   - RIGHT: \`( $COOH$ )\`
   - WRONG: \`90 \n 0\`
   - RIGHT: \`90$^\circ$\`
   - WRONG: \`$\lambda$ \n and an increase\`
   - RIGHT: \`$\lambda$ and an increase\`
   - WRONG: \`( \n K \n )\` or \`( \n Na \n )\`
   - RIGHT: \`( $K$ )\` or \`( $Na$ )\`
   `;

        const userPrompt = `
            Based on the document context, explain the answer to this question:
            Question: ${currentQuestionData.question}
            Options: ${JSON.stringify(currentQuestionData.options)}
            Correct Answer: ${currentQuestionData.options[currentQuestionData.correctAnswerIndex]}
        `;

        try {
            let explanation = await callGemini(systemPrompt, userPrompt, true, false);
            // Basic markdown to HTML
            explanation = explanation
                .replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>') // Bold
                .replace(/\*(.*?)\*/g, '<em>$1</em>') // Italics
                .replace(/\n/g, '<br>'); // Newlines
            explanationContainer.innerHTML = explanation;
            if (window.MathJax) {
                window.MathJax.typesetPromise([explanationContainer]).catch((err) => console.log('MathJax error:', err));
            }
        } catch (error) {
            explanationContainer.innerHTML = `<p class="text-red-500">Sorry, I couldn't generate an explanation. ${error.message}</p>`;
        } finally {
            explainAnswerBtn.disabled = false;
        }
    });

    // NEW: Generate Key Concepts
    generateSummaryBtn.addEventListener('click', async () => {
        keyConceptsContainer.innerHTML = '<div class="mini-spinner"></div>';
        keyConceptsContainer.classList.remove('hidden');
        generateSummaryBtn.disabled = true;
        generateSummaryBtn.textContent = 'Generating...';

        // **REINFORCED** system prompt for symbol spacing
        const systemPrompt = `You are a helpful study assistant. Analyze the provided documents (images or text from PDFs) and extract a concise, bulleted list of the most important key concepts, definitions, and topics.
RULES:
1. Use Markdown for formatting.
2. If you use mathematical or scientific notation, use standard LaTeX format (e.g., $...$).
3. ABSOLUTELY CRITICAL: You MUST combine scientific symbols and their units *inside* the SAME LaTeX block. NEVER add a space between a symbol and its unit.
   - CORRECT: \`10 $\mu$m\`
   - CORRECT: \`($\mu$g)\`
   - HORRIBLY WRONG (DO NOT DO THIS): \`10 $\mu$ m\`
   - HORRIBLY WRONG (DO NOT DO THIS): \`($\mu$ g)\`
   - HORRIBLY WRONG (DO NOT DO THIS): \`Separation of $\mu$ \n g of the substances.\`
   - The correct version of the above is: \`Separation of $\mu$g of the substances.\`

4. VITAL: Do NOT add extra text or newlines inside or around symbols.
   - WRONG: \`( extCOOH )\`
   - RIGHT: \`( $COOH$ )\`
   - WRONG: \`90 \n 0\`
   - RIGHT: \`90$^\circ$\`
   - WRONG: \`$\lambda$ \n and an increase\`
   - RIGHT: \`$\lambda$ and an increase\`
   - WRONG: \`( \n K \n )\` or \`( \n Na \n )\`
   - RIGHT: \`( $K$ )\` or \`( $Na$ )\`
   `;

        const userPrompt = "Generate the key concepts summary from these documents.";

        try {
            let concepts = await callGemini(systemPrompt, userPrompt, true, false);
            // Basic markdown to HTML
            concepts = concepts
                .replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>')
                .replace(/\* (.*?)(?=\n\* |\n\n|$)/g, '<li class="ml-4 list-disc">$1</li>') // Bullets
                .replace(/\n/g, '<br>')
                .replace(/<br><li/g, '<li'); // Fix spacing
            keyConceptsContainer.innerHTML = `<h3 class="font-bold text-lg mb-2">Key Concepts</h3><ul>${concepts}</ul>`;
            if (window.MathJax) {
                window.MathJax.typesetPromise([keyConceptsContainer]).catch((err) => console.log('MathJax error:', err));
            }
        } catch (error) {
            keyConceptsContainer.innerHTML = `<p class="text-red-500">Sorry, I couldn't generate the summary. ${error.message}</p>`;
        }
    });

    // --- END NEW GEMINI FUNCTIONS ---


    function displayQuestion(questionData) {
        if (!questionData) {
            handleFetchError(new Error("Received empty question data."));
            return;
        };
        
        currentQuestionData = questionData;
        
        // Add to history *before* time is recorded
        questionHistory.push({
            question: questionData.question,
            options: questionData.options,
            correctIdx: questionData.correctAnswerIndex,
            selectedIdx: null,
            timeTaken: 0 // Initialize timeTaken
        });
        
        totalQuestions++;
        questionCountDisplay.textContent = totalQuestions;
        questionText.textContent = questionData.question;
        optionsContainer.innerHTML = '';

        questionData.options.forEach((option, index) => {
            const button = document.createElement('button');
            button.textContent = option;
            button.classList.add('option-btn', 'w-full', 'text-left', 'p-4', 'border-2', 'rounded-lg', 'bg-white', 'hover:border-indigo-400', 'focus:outline-none', 'focus:ring-2', 'focus:ring-indigo-400');
            button.dataset.index = index;
            button.addEventListener('click', handleOptionSelect);
            optionsContainer.appendChild(button);
        });
        
        // Render MathJax
        if (window.MathJax) {
            window.MathJax.typesetPromise([questionText, optionsContainer]).catch((err) => console.log('MathJax error:', err));
        }
        
        // Start pre-fetching the *next* question
        fillQuestionBuffer();
        
        // NEW: Start question timer
        if (questionTimerInterval) clearInterval(questionTimerInterval);
        timerDisplay.textContent = '0';
        questionStartTime = Date.now();
        questionTimerInterval = setInterval(() => {
            timerDisplay.textContent = Math.floor((Date.now() - questionStartTime) / 1000);
        }, 1000);
    }

    function handleOptionSelect(event) {
        // NEW: Stop the timer
        if (questionTimerInterval) clearInterval(questionTimerInterval);
        const timeTaken = Math.floor((Date.now() - questionStartTime) / 1000);
        
        const selectedButton = event.target;
        const selectedIndex = parseInt(selectedButton.dataset.index);
        
        if (!currentQuestionData || currentQuestionData.correctAnswerIndex === undefined) {
            console.error("currentQuestionData is invalid:", currentQuestionData);
            feedbackContainer.textContent = "An error occurred with this question. Moving on.";
            feedbackContainer.classList.add('text-red-500');
            nextQuestionBtn.classList.remove('hidden');
            return;
        }
        
        const correctIndex = currentQuestionData.correctAnswerIndex;
        
        // Log this attempt in history
        questionHistory[questionHistory.length - 1].selectedIdx = selectedIndex;
        questionHistory[questionHistory.length - 1].timeTaken = timeTaken; // NEW: Save time
        
        const optionButtons = optionsContainer.querySelectorAll('.option-btn');
        optionButtons.forEach(btn => btn.disabled = true);

        if (selectedIndex === correctIndex) {
            attempts++;
            selectedButton.classList.add('correct');
            feedbackContainer.textContent = congratulatoryMessages[Math.floor(Math.random() * congratulatoryMessages.length)];
            feedbackContainer.classList.remove('text-red-500');
            feedbackContainer.classList.add('text-green-600');
            if (attempts === 1) { // Only add to score if correct on the first try
                score++;
                scoreDisplay.textContent = score;
            }
        } else {
            attempts++;
            selectedButton.classList.add('incorrect');
            // Highlight the correct answer
            optionButtons[correctIndex].classList.add('correct');
            feedbackContainer.textContent = encouragementMessages[Math.floor(Math.random() * encouragementMessages.length)];
            feedbackContainer.classList.remove('text-green-600');
            feedbackContainer.classList.add('text-red-500');
        }

        // Reset attempts for the next question
        attempts = 0;
        nextQuestionBtn.classList.remove('hidden');
        explainAnswerBtn.classList.remove('hidden'); // Show explain button
    }
    
    function handleFetchError(error) {
        console.error("Error fetching question:", error);
        let userMessage = `Sorry, I couldn't generate a question: ${error.message}`;
        if (error.message.includes("No content received")) {
            userMessage = "The AI couldn't find a suitable question in your document. Please try a different file.";
        } else if (error.message.includes("API key not valid")) {
            userMessage = "Your API Key is invalid. Please refresh and enter a valid key.";
        } else if (error.message.includes("timed out")) {
             userMessage = "The AI request timed out. Please check your connection and try again.";
        } else if (error.message.includes("Failed to fetch")) {
             userMessage = "A network error occurred. Please check your connection.";
        } else if (error.message.includes("detached ArrayBuffer")) {
             userMessage = "A file processing error occurred. Please try re-uploading your files.";
        } else if (error.message.includes("overloaded")) {
             userMessage = "The AI is currently overloaded. The app tried to reconnect but failed. Please try again in a moment.";
        }
        
        feedbackContainer.textContent = userMessage;
        feedbackContainer.classList.add('text-red-500');
        
        // Show "End Quiz" button if it's the first question, otherwise "Next"
        if(totalQuestions === 0) {
             // If preload fails, totalQuestions is 0. Show End Quiz to let user exit.
             endQuizBtn.classList.remove('hidden');
        } else {
            // If a mid-quiz fetch fails, show Next to allow retry.
            nextQuestionBtn.classList.remove('hidden');
        }
    }

    function showResults() {
        if (questionTimerInterval) clearInterval(questionTimerInterval); // Stop any running timer
        quizSection.classList.add('hidden');
        resultSection.classList.remove('hidden');
        appHeader.classList.remove('hidden');

        // NEW: Display student info
        studentSummaryInfo.innerHTML = '';
        if (studentName || studentSemester) {
            let infoHtml = '';
            if (studentName) infoHtml += `<p class="text-lg text-gray-600"><strong>Name:</strong> ${studentName}</p>`;
            if (studentSemester) infoHtml += `<p class="text-lg text-gray-600"><strong>Semester:</strong> ${studentSemester}</p>`;
            infoHtml += '<hr class="my-4">';
            studentSummaryInfo.innerHTML = infoHtml;
            studentSummaryInfo.classList.remove('hidden');
        } else {
            studentSummaryInfo.classList.add('hidden');
        }

        const questionsAttempted = totalQuestions > 0 ? totalQuestions : 0;
        finalScoreDisplay.textContent = `${score} / ${questionsAttempted}`;
        
        const percentage = questionsAttempted > 0 ? Math.round((score / questionsAttempted) * 100) : 0;
        finalPercentageDisplay.textContent = `${percentage}%`;

        // --- Show Motivation ---
        if(currentLottie) currentLottie.destroy(); // Clear previous animation
        let motivationMsg = "";
        let lottieUrl = "";

        if (percentage >= 80) {
            motivationMsg = "Your progress is outstanding! Truly brilliant work!";
            lottieUrl = 'https://lottie.host/86d6f2c8-886f-4c5c-9c88-e8b83921762c/fVl2TE4EfA.json'; // Trophy
        } else if (percentage >= 50) {
            motivationMsg = "Great job! You're clearly improving and learning fast!";
            lottieUrl = 'https://lottie.host/a61e053a-93f4-4a25-83f5-7d7166162130/b0YtL1kC3E.json'; // Growth arrow
        } else if (percentage >= 25) {
            motivationMsg = "Solid effort! Keep pushing, you'll master it next time!";
            lottieUrl = 'https://lottie.host/5a07e1e6-052b-47e1-b485-618451120b60/eL1jQW8VqS.json'; // Sprout/plant
        } else {
            motivationMsg = "Every quiz is a chance to learn. Keep at it!";
            lottieUrl = 'https://lottie.host/249b9961-9f93-45f4-a039-9d9f1e102e3b/e8qgqS6gqC.json'; // Lightbulb
        }

        motivationText.textContent = motivationMsg;
        currentLottie = lottie.loadAnimation({
            container: lottieAnimation,
            renderer: 'svg',
            loop: true,
            autoplay: true,
            path: lottieUrl
        });


        // --- Build and display summary ---
        summaryContainer.innerHTML = '';
        if (questionHistory.length === 0) {
            summaryContainer.innerHTML = '<p class="text-gray-500 text-center">No questions were answered in this session.</p>';
        }

        questionHistory.forEach((item, index) => {
            if (!item || item.options === undefined) {
                console.warn("Skipping invalid history item:", item);
                return;
            }

            const summaryItem = document.createElement('div');
            summaryItem.classList.add('p-4', 'rounded-lg', 'border', 'bg-gray-50');

            let optionsHtml = item.options.map((opt, i) => {
                let classes = 'block p-2 rounded-md mt-1';
                if (i === item.correctIdx) {
                    classes += ' bg-green-100 text-green-800 font-medium';
                }
                if (i === item.selectedIdx && i !== item.correctIdx) {
                    classes += ' bg-red-100 text-red-800 line-through';
                } else if (i === item.selectedIdx) {
                    classes += ' font-medium';
                }
                return `<span class="${classes}">${opt}</span>`;
            }).join('');

            // NEW: Add time taken to summary
            // CHANGED: "Time:" to "Time Taken:"
            const timeText = item.timeTaken !== undefined ? `${item.timeTaken} seconds` : 'N/A';

            summaryItem.innerHTML = `
                <div class="flex justify-between items-center">
                    <p class="font-bold text-gray-800 mb-2">Question ${index + 1}:</p>
                    <p class="text-sm text-gray-500 mb-2">Time Taken: ${timeText}</p>
                </div>
                <p class="font-semibold text-gray-700 mb-2">${item.question}</p>
                <div class="space-y-1">${optionsHtml}</div>
            `;
            summaryContainer.appendChild(summaryItem);
        });
        
         // Render MathJax for the *entire* summary container
         if (window.MathJax) {
            window.MathJax.typesetPromise([summaryContainer]).catch((err) => console.log('MathJax error:', err));
        }
    }

    function showLoader(isLoading, mainText = "Your AI is thinking...", showSpinner = true) {
        clearTimeout(loaderTimer5s);
        clearTimeout(loaderTimer10s);
        
        if (isLoading) {
            loaderMainText.textContent = mainText;
            loaderSubText.textContent = "Please wait a moment...";
            loaderSpinner.style.display = showSpinner ? 'block' : 'none';
            
            if (showSpinner) {
                 loaderSubText.textContent = "Generating a unique question...";
                 loaderTimer5s = setTimeout(() => {
                    loaderMainText.textContent = "Thinking deeply...";
                    loaderSubText.textContent = "Analyzing the details for a better response.";
                }, 5000);

                loaderTimer10s = setTimeout(() => {
                    loaderMainText.textContent = "Almost there...";
                    loaderSubText.textContent = "Crafting the perfect question just for you.";
                }, 10000);
            }
            loader.classList.remove('hidden');
        } else {
            loader.classList.add('hidden');
        }
    }

</script>
</body>
</html>

